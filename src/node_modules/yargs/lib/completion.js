<<<<<<< HEAD
'use strict'
=======
>>>>>>> 40b68b803b32f109350a2917c9a607927080fd74
const fs = require('fs')
const path = require('path')

// add bash completions to your
//  yargs-powered applications.
<<<<<<< HEAD
module.exports = function completion (yargs, usage, command) {
=======
module.exports = function (yargs, usage, command) {
>>>>>>> 40b68b803b32f109350a2917c9a607927080fd74
  const self = {
    completionKey: 'get-yargs-completions'
  }

  // get a list of completion commands.
  // 'args' is the array of strings from the line to be completed
<<<<<<< HEAD
  self.getCompletion = function getCompletion (args, done) {
=======
  self.getCompletion = function (args, done) {
>>>>>>> 40b68b803b32f109350a2917c9a607927080fd74
    const completions = []
    const current = args.length ? args[args.length - 1] : ''
    const argv = yargs.parse(args, true)
    const aliases = yargs.parsed.aliases

    // a custom completion function can be provided
    // to completion().
    if (completionFunction) {
      if (completionFunction.length < 3) {
<<<<<<< HEAD
        const result = completionFunction(current, argv)

        // promise based completion function.
        if (typeof result.then === 'function') {
          return result.then((list) => {
            process.nextTick(() => { done(list) })
          }).catch((err) => {
            process.nextTick(() => { throw err })
=======
        var result = completionFunction(current, argv)

        // promise based completion function.
        if (typeof result.then === 'function') {
          return result.then(function (list) {
            process.nextTick(function () { done(list) })
          }).catch(function (err) {
            process.nextTick(function () { throw err })
>>>>>>> 40b68b803b32f109350a2917c9a607927080fd74
          })
        }

        // synchronous completion function.
        return done(result)
      } else {
        // asynchronous completion function
<<<<<<< HEAD
        return completionFunction(current, argv, (completions) => {
=======
        return completionFunction(current, argv, function (completions) {
>>>>>>> 40b68b803b32f109350a2917c9a607927080fd74
          done(completions)
        })
      }
    }

<<<<<<< HEAD
    const handlers = command.getCommandHandlers()
    for (let i = 0, ii = args.length; i < ii; ++i) {
=======
    var handlers = command.getCommandHandlers()
    for (var i = 0, ii = args.length; i < ii; ++i) {
>>>>>>> 40b68b803b32f109350a2917c9a607927080fd74
      if (handlers[args[i]] && handlers[args[i]].builder) {
        const builder = handlers[args[i]].builder
        if (typeof builder === 'function') {
          const y = yargs.reset()
          builder(y)
          return y.argv
        }
      }
    }

    if (!current.match(/^-/)) {
<<<<<<< HEAD
      usage.getCommands().forEach((usageCommand) => {
        const commandName = command.parseCommand(usageCommand[0]).cmd
        if (args.indexOf(commandName) === -1) {
          completions.push(commandName)
=======
      usage.getCommands().forEach(function (command) {
        if (args.indexOf(command[0]) === -1) {
          completions.push(command[0])
>>>>>>> 40b68b803b32f109350a2917c9a607927080fd74
        }
      })
    }

    if (current.match(/^-/)) {
<<<<<<< HEAD
      Object.keys(yargs.getOptions().key).forEach((key) => {
        // If the key and its aliases aren't in 'args', add the key to 'completions'
        const keyAndAliases = [key].concat(aliases[key] || [])
        const notInArgs = keyAndAliases.every(val => args.indexOf(`--${val}`) === -1)
        if (notInArgs) {
          completions.push(`--${key}`)
=======
      Object.keys(yargs.getOptions().key).forEach(function (key) {
        // If the key and its aliases aren't in 'args', add the key to 'completions'
        var keyAndAliases = [key].concat(aliases[key] || [])
        var notInArgs = keyAndAliases.every(function (val) {
          return args.indexOf('--' + val) === -1
        })
        if (notInArgs) {
          completions.push('--' + key)
>>>>>>> 40b68b803b32f109350a2917c9a607927080fd74
        }
      })
    }

    done(completions)
  }

  // generate the completion script to add to your .bashrc.
<<<<<<< HEAD
  self.generateCompletionScript = function generateCompletionScript ($0, cmd) {
    let script = fs.readFileSync(
      path.resolve(__dirname, '../completion.sh.hbs'),
      'utf-8'
    )
    const name = path.basename($0)

    // add ./to applications not yet installed as bin.
    if ($0.match(/\.js$/)) $0 = `./${$0}`

    script = script.replace(/{{app_name}}/g, name)
    script = script.replace(/{{completion_command}}/g, cmd)
=======
  self.generateCompletionScript = function ($0) {
    var script = fs.readFileSync(
      path.resolve(__dirname, '../completion.sh.hbs'),
      'utf-8'
    )
    var name = path.basename($0)

    // add ./to applications not yet installed as bin.
    if ($0.match(/\.js$/)) $0 = './' + $0

    script = script.replace(/{{app_name}}/g, name)
>>>>>>> 40b68b803b32f109350a2917c9a607927080fd74
    return script.replace(/{{app_path}}/g, $0)
  }

  // register a function to perform your own custom
  // completions., this function can be either
  // synchrnous or asynchronous.
<<<<<<< HEAD
  let completionFunction = null
  self.registerFunction = (fn) => {
=======
  var completionFunction = null
  self.registerFunction = function (fn) {
>>>>>>> 40b68b803b32f109350a2917c9a607927080fd74
    completionFunction = fn
  }

  return self
}
